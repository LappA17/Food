function showThis () {
    console.log(this);
}
showThis();
/* в консоли браузера я получил window - это глобальный объект но это если нет "use stict" в начале
кода - то-есть правило строгого кода 

1) обычная функция: this = window, но если стоит use strict, то то будет undefined*/

function showThis (a, b) {
    console.log(this);
    function sum () { //эта функция будет мне возвращать суму двух аргументом и эти аргументы будут передоваться в showThis ()
        console.log(this);//этот консоль лог будет так же undefined потому что не важно где функция запускается, самое главное что у нее контекст вызова будет такой же либо window либо undefined по-этому даже если у нас используется функция внутри функции контекст не меняется
        return a + b; //this.a + this.b нужно убрать this от a и b что бы сделать замыкание функции, да этих переменных a и b у функции sum нет, но за счет того что у нас есть замыкание функции - мы запускаем sum, она ищет сначала эти переменные внутри себя, она их не находит и она обращается к родительской функции, по-этому она найдет 4 и 5
    }
    console.log(sum());
}
showThis(4, 5);//передаем аргументы 4,5

const obj = {
    a: 20,
    b: 15,
    sum: function {
        console.log(this)
    }
};
obj.sum();
/* МЕТОДЫ ОБХЕКТА = ЭТО ТОЖЕ ФУНКЦИИ 
в консоли мы получим тот объект в котором находится этот метод

2) Контекст у методов объекта - это будет сам объект*/

const obj = {
    a: 20,
    b: 15,
    sum: function {
        function shout () {
            console.log(this);//сейчас мы смотрим контекст вызова именно функции shout и такой скрипт будет UNDEFINED в консоли браузера. Потому что это простой вызов функции, он уже не отноится к методу объекта, эта функция запускается внутри метода
        }
        shout();
    }
};
obj.sum();

function User (name, id) {
    this.name = name;
    this.id = id;
    this.human = true;
}
let Ivan = new User ("Ivan", 23);
/* this всегда ссылается на новосозданный объект, в нашем случае это Ivan. Просто вместо this нужно в уме подставлять новую переменную и под него уже подставляются значения нового объекта

3) this в конструкторах и классаъ = НОВЫЙ ЭКЗЕМПЛЯО ОБЪЕКТА !!! */

function sayName () {
    console.log(this);
    console.log(this.name);
}
let User = {
    name: John
}
sayName.call(user);// метод call, и во внутрь передаем контекст вызова который мы хотим передать в эту функцию
sayName.apply(user);// метод apply. Эти функции делают одно и то же, разницы в функционале нет, только в синтаксисе
/* если мы выведем это в консоль то мы получим контекст вызова тот объект к которому мы действително привзались {name: John} John - а это имя этого объекта.  и еще раз {name: John} John
Таки образом мы можем гибко контролировать этот контекст вызова !*/

function sayName (surname) {
    console.log(this);
    console.log(this.name + surname);//теперь аргумент surname нам нужно куда-то передать, а именно в call и apply
}
let User = {
    name: John
}
sayName.call(user, "Smith") //здесь в виде строки через запятую передаются аргумента
sayName.apply(user, ["Smith"]) // здесь в видe массива тоже через запятую. Разница между колл и эплай только в синтаксисе
//теперь в консоли в бразуере будет {name: John} JohnSmith

function count(num) {
    return this * num;
}
const double = count.bind(2);//в переменную double мы помещаем новую функцию. А в bind помещаем двойку, потому что она должна удовевать число которое прийдет в эту функцию. ТО-ЕСТЬ ДВОЙКА БУДЕТ ПЕРЕХОДИТЬ В this ,
console.log(double(3))// а num будет передовать в функциб double. То есть функция дабл - это новая функция которая жестка привязана к контексту this 

/* bind - метод который создает новую функцию и под нее уже подвязывает контекст. В call и apply мы функцию не вызывали, мы просто контекст установили 

теперь в консоли браузере будет 6 

4) Ручная привязка this: call, apply, bind 

Теперь это все можно опробывать на оброботчиках событий. Представь что в html у нас есть кнопка button*/

const btn = document.querySelector("button");
btn.addEventListener("click", function () {
    console.log(this)
});
/*теперь каждый раз мы получаем саму же кнопку в консоль из-за this. Обрати внимание что это коллбек функци но не стрелочная

Важное правило : когда у нас обработчик событий , который идет как callback функция написанны в классическом режиме , то есть без стрелочной , то наш контекст вызова будет сам элемент на котором произошло события, в нашем случае button. По простому this будет равняться тому же что и even.targer */
const btn = document.querySelector("button");
btn.addEventListener("click", function () {
    this.style.backgroundColor = "red";//тепреь кнопка будет красного цвета на сайте :), то же самое мы можем сделать если будет использовать even.target 
});

// Стрелочная функция теперь !
/* стрелочную функцию можно использовать, но всегда нужно помнить про одну особенную фишку этой функции, а именно то что у стрелочной функции нет своего контекста вызова, она всегда будет его брать у своего родителя*/

const obj = {
    num: 5,
    sayNumber: function () {
        const say =  () => {
            console.log(this);//здесь если бы это была бы обычная функция, то this просто был бы undefined, но у стрелочной функции нет своего контекста, по этому контект она берет у родителя , а родитель является метод sayNumber , а у метода всегда ссылка идет на объкт в котором он существует. То-есть this будет ссылаться на сам объект. ТЕПРЕЬ КОГДА ВЫВОДИМ В КОНСОЛЬ this превращаемся в сам объект
            console.log(this.num)//будет 5 в консоли , потому что функция say обратилась к контексту вызова = объекту и взял свойство num
        }
        say();
    }
};
obj.sayNumber();

const double = (a) => {
    return a * 2; //так бы мы могли написать в классическом варианте, то-есть функция double будет нам возвращать а умноженое на 2
}
const double = (a) => a * 2 // это будет тоже самое что выше, нужно ЗАПОМНИТЬ что если ваше действие помещается в одну строчку вы можете вывести ее вот таким вот образом при чем слово return ставить не нужно, оно ставится автоматически
const double = a => a * 2// можно даже так написать. НО ЕСЛИ БУДЕТ БОЛЬШЕ 2 АРГУМЕНТОВ ТО НУЖНО ОБОРАЧИВАТЬ В КРУГЛЫЕ СКОБКИ (a, b) иначе будет ошибка
console.log(double(4));
/*[Running] node "/Users/Ruslan/Desktop/Work/Project/Main/tempCodeRunnerFile.js"
  8 */

  const btn = document.querySelector("button");
    btn.addEventListener("click",  () => {
        this.style.backgroundColor = "red";
});
/* в таком случае будет undefined. То есть контекст вызова здесь потерялся , если не будет use strict то window
То есть если мы будем использоваться обычный синтаксис через function то будет все работать как на примере там выше где все ровно так же только не стрелачная функция а обычная, где this будет как even.target, а стрелочная теряется */

const btn = document.querySelector("button");
    btn.addEventListener("click",  (e) => {
        e.target.style.backgroundColor = "red";
});
/*вот так все будет работать ! */