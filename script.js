const timerId  = setTimeout(function(text){
    console.log(text);
}, 2000, "Hello");
/* 2000 это таймаут с которым вызовится ф-ция, только в МИЛЛИСЕКУНДАХ
text - я говорю что в консоль будет переводится тот текст который передаетя во внутрь этой
ф-ции
hello - это третий аргумент которая запускается как таймаут, это используется не часто но такое существует
*/

const timerId  = setTimeout(logger , 2000);

function logger () {
    console.log(text);
}
/* таким образом мы передаем ф-цию в таймаут, мы ее не вызываем, а именно передаем 
ЕСЛИ МЫ НЕ БУДЕМ СОЗДАВАТЬ ПЕРЕМЕННУЮ ТО Ф-ЦИЯ БУДЕТ ТАК ЖЕ РАБОТАТЬ И БЕЗ НЕЕ, К ПРИМЕРУ ЕСЛИ ПРОСТО НАПИСАТЬ 
setTimeout(...) , а в константу мы их задаем потому что в будущем в больших проектах таких функция может быть 
очень много и нам прийдется с ними взаимодействовать по константе или к примеру пользователю должно выскочить окно 
подписать но если он уже подписался то через условие и переменной нужно что бы окно не выскакивало*/

const timerId  = setTimeout(logger , 2000);

clearInterval(timerId);

function logger () {
    console.log(text);
}
/* clearInterval - останавливает таймер */

const btn = document.querySelector(".btn");
btn.addEventListener("click", () => {
    const timerId  = setTimeout(logger , 2000);
});
clearInterval(timerId);
function logger () {
    console.log(text);
}

/* мы говорим что после клика у нас будет запускаться таймер
 НО clearInterval Работать НЕ БУДЕТ ПОТОМУ ЧТО ОН ЛОКАЛЬНО НАХОДИТСЯ ЗА Ф-ЦИЕЙ*/

 const btn = document.querySelector(".btn");
btn.addEventListener("click", () => {
    const timerId  = setInterval(logger , 2000);
});

clearInterval(timerId);

function logger () {
    console.log(text);
}
/*благодаря setInterval в консоли будет каждые 2 секунды до бесконечноти появлятся надпись из консоль лог а именно текст*/
const btn = document.querySelector(".btn");
let timerId;

btn.addEventListener("click", () => {
    timerId = setInterval(logger , 2000);
});

clearInterval(timerId);

function logger () {
    console.log(text);
}
/*в начале мы создаем переменую timerId. после того как в нее кликнули в нее запишеться уникальный идентификатор
который существовал только в локальной области видимости но за счет того у нас есть глобальная переменная, мы ее переза-
писали и теперь  этот глобальный идентификатор можем использовать в команде clearInterval
Помни что когда ф-ция не может найти переменую внутри себя она подимается на уровень выше !!!
Но даже так clearintervl работать не будет потому что внутри таймер айди ничего нет*/

const btn = document.querySelector(".btn");
let timerId,
    i = 0;

btn.addEventListener("click", () => {
    timerId = setInterval(logger , 500);
});

clearInterval(timerId);

function logger () {
    if (i === 3){
        clearInterval(timerId);
    };
    console.log(text);
    i++;
}
/* вот теперь все будет работать, когда 4жды (из-за ай рово 3), выскачит в консоли текст, то потом clearInterval сработает
и стопанет таймер 

 ТЕПЕРЬ О ПРОБЛЕМЕ: ПРЕДСТАВЬ ЧТО У ТЕБЯ НЕ ОБЫЧНАЯ ЛЕГКАЯ Ф-ЦИЯ, А ТАКАЯ КОТОРАЯ ЗАНИМАЕТ НАПРИМЕР 3 СЕКУНДЫ ДЛЯ ВЫПОЛНЕНИЯ
 ПО ЛОГИКЕ ТЫ ДУМАЕШЬ ЧТО 3 СЕКУ Ф-ЦИЯ, ПОТОМ ИНТЕРВАЛ ПОЛ СЕКСУНДЫ, ПОТОМ ОПЯТЬ ТРИ СЕКУНДЫ Ф-ЦИИ И ТАК ДАЛЕЕ, НО НА ПРАК-
 ТИКЕ КОГДА ТЯЖЕЛАЯ Ф-ЦИЯ ТО ВСЕ РАБОТАЕТ ПО ДРУГОМУ: А ИМЕННО ТАЙМЕР ДУМАЕТ ЧТО ЭТИ ПОЛ СЕКУНДЫ УЖЕ ПРОШЛИ И ЗАПУСКАЕ ЕЕ
 ЗАНОВО, ОН НЕ ЗНАЕТ ЧТО Ф-ЦИЯ ДЛИТЬСЯ САМА ПО СЕБЕ 3 СЕКУНДЫ, ОН ДУМАЕТ ЧТО ОНА РАБОТАЕТ МОМЕНТАЛЬНО И ДЛЯ РЕШЕНИЯ ТАКОЙ ПРО-
 БЛЕМЫ ОБЫЧНО ИСПОЛЬЗУЮТ РЕКРУСИВНЫЙ ВЫЗОВ setTimeout*/

 let id = setTimeout(function log(){
     console.log("hello");
     id = setTimeout(log, 500);
 }, 500);
 /* все будет работать точно так же - до бесконечности будет писаться hello в консоли, но разница в том что КОД БУДЕТ ЖДАТЬ
 СТРОГО ОТВЕДЕННОЕ ЕМУ ВРЕМЯ. То есть теперь setTimeout будет ждать пока ф-ция какая долгая она бы не была закончится -
 потом подождем пол секунды - запустит еще раз  и тд*/

 const btn = document.querySelector(".btn");
 let timerId,
     i = 0;

function myAnimation() {
    const elem = document.querySelector(".box");
    let pos = 0;

    const id = setInterval(frame,10);

    function frame () {
        if(pos == 300) {
            clearInterval(id);
        } else {
            pos++;
            elem.style.top = pos + "px";
            elem.style.left = pos + "px";
        }
    }
}
    btn.addEventListener("click", myAnimation);
/* так делали давным давным давно
pos = 0 это позиция с которой будет все стартовать и все изменятся
в функции frame мы должны написать условие как определить что наша анимация закончилась, благодаря pos 
elem.style.top - у него там квадратик в левом верхнем угле который благодаря css стилю должен будет двигаться в правый
нижний угол 

функция frame - должна запускаться через какой-то промежуток времени
в frame мы прописываем условие как нам определить что наша анимация закончилась
pos === 300 это наше конечно значение и если кубик достигает этой позиции то clearInterval  стопарит анимацию
а в else мы пишем какие действие будут если наша анимация еще не закончилась или продолжается
и в else мы увеличиваем начальную позицию на единичку и благодаря инлайн стился двигаем элемент
Теперь когда он нажимает на кнопку Animation этот кубик едет с углу в угол 
elem.style.top или left  = pos + "px" мы говорим наша текущая позици + пиксель 

const id = setInterval(frame,10) - теперь мы добавляем переменную с интервалом : frame - это функция которую мы будем запускать
а 10 это интервал в мс ее повторения 
теперь мы передаем clearInterval() который изначально пустой id ведь как только наш кубик достигнит нужной нам позиции
мы будем очищать этот интервал и все, наша анимация остановиться 

    btn.addEventListener("click", myAnimation); - это мы назначили тригер нашей анимации
*/